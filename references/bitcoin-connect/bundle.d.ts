// Generated by dts-bundle-generator v9.5.1

// Workaround for code completion to account for values this library doesn't know about yet.
// This allows TypeScript to understand that AdditionalString is a string that is distinct from the string literal type.
export type AdditionalString = string & {
	_additionalString?: never;
};
export type WebLNRequestMethod = "request.getinfo" | "request.listchannels" | "request.listinvoices" | "request.channelbalance" | "request.walletbalance" | "request.openchannel" | "request.connectpeer" | "request.disconnectpeer" | "request.estimatefee" | "request.getchaninfo" | "request.getnetworkinfo" | "request.getnodeinfo" | "request.gettransactions" | "request.listpayments" | "request.listpeers" | "request.lookupinvoice" | "request.queryroutes" | "request.verifymessage" | "request.sendtoroute" | "request.decodepayreq" | "request.routermc" | "request.addinvoice" | AdditionalString;
export type WebLNMethod = keyof WebLNProvider | AdditionalString;
export interface WebLNNode {
	alias: string;
	pubkey: string;
	color?: string;
}
export interface GetInfoResponse {
	node: WebLNNode;
	version: string;
	supports: ("lightning" | AdditionalString)[];
	methods: (WebLNRequestMethod | WebLNMethod)[];
}
export interface SendPaymentResponse {
	preimage: string;
}
export interface RequestInvoiceArgs {
	amount?: string | number;
	defaultAmount?: string | number;
	minimumAmount?: string | number;
	maximumAmount?: string | number;
	defaultMemo?: string;
}
export interface KeysendArgs {
	destination: string;
	customRecords?: Record<string, string>;
	amount: string | number;
}
export interface MakeInvoiceResponse {
	paymentRequest: string;
}
export interface SignMessageResponse {
	message: string;
	signature: string;
}
export type LNURLResponse = {
	status: "OK";
} | {
	status: "ERROR";
	reason: string;
};
export interface GetBalanceResponse {
	balance: number;
	currency?: string;
}
export interface LookupInvoiceArgs {
	invoice?: string;
	payment_hash?: string;
}
export interface LookupInvoiceResponse {
	paymentRequest: string;
	paid: boolean;
}
export interface WebLNProvider {
	enable(): Promise<void>; // Promise<{ enabled: boolean; remember: boolean }>
	getInfo(): Promise<GetInfoResponse>;
	makeInvoice(args: string | number | RequestInvoiceArgs): Promise<MakeInvoiceResponse>;
	sendPayment(paymentRequest: string): Promise<SendPaymentResponse>;
	// optional methods
	isEnabled?(): Promise<boolean>;
	getBalance?(): Promise<GetBalanceResponse>;
	keysend?(args: KeysendArgs): Promise<SendPaymentResponse>;
	lnurl?(lnurl: string): Promise<LNURLResponse>;
	lookupInvoice?(args: LookupInvoiceArgs): Promise<LookupInvoiceResponse>;
	request?: (method: WebLNRequestMethod, args?: unknown) => Promise<unknown>;
	signMessage?(message: string): Promise<SignMessageResponse>;
	verifyMessage?(signature: string, message: string): Promise<void>;
	on?(eventName: string, listener: () => void): void;
	off?(eventName: string, listener: () => void): void;
}
declare class ExtensionConnector extends Connector {
	constructor(config: ConnectorConfig);
	init(): Promise<WebLNProvider>;
}
declare class LnbitsConnector extends Connector {
	constructor(config: ConnectorConfig);
	init(): Promise<WebLNProvider>;
}
declare class LnbitsWebLNProvider implements WebLNProvider {
	private _instanceUrl;
	private _adminKey;
	constructor(lnbitsUrl: string, lnbitsAdminKey: string);
	enable(): Promise<void>;
	getInfo(): Promise<GetInfoResponse>;
	makeInvoice(args: string | number | RequestInvoiceArgs): Promise<MakeInvoiceResponse>;
	sendPayment(paymentRequest: string): Promise<SendPaymentResponse>;
	getBalance(): Promise<GetBalanceResponse>;
	keysend(_args: KeysendArgs): Promise<SendPaymentResponse>;
	lnurl(_lnurl: string): Promise<{
		status: "OK";
	} | {
		status: "ERROR";
		reason: string;
	}>;
	lookupInvoice(_args: LookupInvoiceArgs): Promise<LookupInvoiceResponse>;
	request: ((method: WebLNRequestMethod, args?: unknown) => Promise<unknown>) | undefined;
	signMessage(_message: string): Promise<SignMessageResponse>;
	verifyMessage(_signature: string, _message: string): Promise<void>;
	requestLnbits<T>(method: string, path: string, args?: Record<string, unknown>): Promise<T>;
}
declare class NWCConnector extends Connector {
	constructor(config: ConnectorConfig);
	init(): Promise<WebLNProvider>;
}
declare const connectors: {
	"extension.generic": typeof ExtensionConnector;
	"nwc.alby": typeof NWCConnector;
	"nwc.albyhub": typeof NWCConnector;
	"nwc.generic": typeof NWCConnector;
	"nwc.lnfi": typeof NWCConnector;
	"nwc.coinos": typeof NWCConnector;
	"nwc.flash": typeof NWCConnector;
	"nwc.primal": typeof NWCConnector;
	"nwc.cashume": typeof NWCConnector;
	"nwc.lnbits": typeof NWCConnector;
	"nwc.rizful": typeof NWCConnector;
	lnbits: typeof LnbitsConnector;
	lnc: typeof LNCConnector;
};
export declare type ConnectorType = keyof typeof connectors;
export declare type ConnectorConfig = {
	connectorName: string;
	connectorType: ConnectorType;
	nwcUrl?: string;
	lnbitsInstanceUrl?: string;
	lnbitsAdminKey?: string;
};
declare abstract class Connector {
	protected _config: ConnectorConfig;
	constructor(config: ConnectorConfig);
	abstract init(): Promise<WebLNProvider>;
	unload(): Promise<void>;
}
declare class LNCConnector extends Connector {
	constructor(config: ConnectorConfig);
	init(): Promise<WebLNProvider>;
	unload(): Promise<void>;
}
declare class LNCWebLNProvider implements WebLNProvider {
	lnc: LNC;
	constructor(lnc: LNC);
	enable(): Promise<void>;
	getInfo(): Promise<GetInfoResponse>;
	makeInvoice(_args: string | number | RequestInvoiceArgs): Promise<MakeInvoiceResponse>;
	sendPayment(paymentRequest: string): Promise<SendPaymentResponse>;
	getBalance(): Promise<GetBalanceResponse>;
	keysend(_args: KeysendArgs): Promise<SendPaymentResponse>;
	lnurl(_lnurl: string): Promise<{
		status: "OK";
	} | {
		status: "ERROR";
		reason: string;
	}>;
	lookupInvoice(_args: LookupInvoiceArgs): Promise<LookupInvoiceResponse>;
	request: ((method: WebLNRequestMethod, args?: unknown) => Promise<unknown>) | undefined;
	signMessage(_message: string): Promise<SignMessageResponse>;
	verifyMessage(_signature: string, _message: string): Promise<void>;
}
declare class InternalElement extends LitElement {
	static styles: import("lit").CSSResult[];
	protected updated(changedProperties: PropertyValues): void;
	protected _getBrandColorLuminance(): number;
}
export declare type ConnectorFilter = "nwc";
declare const ConnectorElement_base: typeof BitcoinConnectElement;
declare abstract class ConnectorElement extends ConnectorElement_base {
	private _background;
	private _icon;
	protected _title: string;
	protected _connectorType: ConnectorType;
	protected abstract _onClick(): void;
	constructor(connectorType: ConnectorType, title: string, background: string, icon: TemplateResult<2>);
	render(): TemplateResult<1>;
	protected _connect(config: Omit<ConnectorConfig, "connectorName" | "connectorType">): void;
}
declare class ExtensionConnector$1 extends ConnectorElement {
	constructor();
	protected _onClick(): void;
}
export declare const albyHubConnectorTitle = "Alby Hub";
export declare class AlbyHubConnector extends ConnectorElement {
	constructor();
	protected _onClick(): Promise<void>;
}
export declare const genericConnectorTitle = "NWC";
export declare class GenericNWCConnector extends ConnectorElement {
	constructor();
	protected _onClick(): Promise<void>;
}
declare class LNCConnector$1 extends ConnectorElement {
	constructor();
	protected _onClick(): Promise<void>;
}
export declare const lnbitsConnectorTitle = "LNbits";
export declare class LNBitsConnector extends ConnectorElement {
	constructor();
	protected _onClick(): Promise<void>;
}
export declare const lnbitsNWCConnectorTitle = "LNbits NWC Plugin";
export declare class LNbitsNWCConnector extends ConnectorElement {
	constructor();
	protected _onClick(): Promise<void>;
}
export declare const lnfiConnectorTitle = "LN Link";
export declare class LnfiNWCConnector extends ConnectorElement {
	constructor();
	protected _onClick(): Promise<void>;
}
export declare const coinosConnectorTitle = "Coinos";
export declare class CoinosConnector extends ConnectorElement {
	constructor();
	protected _onClick(): Promise<void>;
}
export declare const flashConnectorTitle = "Flash Wallet";
export declare class FlashConnector extends ConnectorElement {
	constructor();
	protected _onClick(): Promise<void>;
}
export declare const primalConnectorTitle = "Primal Mobile";
export declare class PrimalConnector extends ConnectorElement {
	constructor();
	protected _onClick(): Promise<void>;
}
export declare const rizfulConnectorTitle = "Rizful";
export declare class RizfulConnector extends ConnectorElement {
	constructor();
	protected _onClick(): Promise<void>;
}
declare const ConnectorList_base: typeof BitcoinConnectElement;
/**
 * A list of available connectors
 */
export declare class ConnectorList extends ConnectorList_base {
	_showAll: boolean;
	render(): TemplateResult<1>;
	private _toggleShowAll;
}
declare const Balance_base: typeof BitcoinConnectElement;
/**
 * Displays the balance of the connected wallet (could be sats or fiat)
 */
export declare class Balance extends Balance_base {
	_balance: string | undefined;
	_balanceSats: number | undefined;
	_loading: boolean;
	_selectedCurrency: string | undefined;
	constructor();
	render(): import("lit").TemplateResult<1>;
	private _convertBalance;
	private _loadBalance;
}
declare const CurrencySwitcher_base: typeof BitcoinConnectElement;
export declare class CurrencySwitcher extends CurrencySwitcher_base {
	_isSwitchingCurrency: boolean;
	_selectedCurrency: string | undefined;
	static styles: import("lit").CSSResult[];
	constructor();
	render(): import("lit").TemplateResult<1>;
	private _showSelectVisibility;
	private _selectCurrency;
}
export declare type PaymentMethods = "all" | "internal" | "external";
declare const SendPayment_base: typeof BitcoinConnectElement;
export declare class SendPayment extends SendPayment_base {
	_hasCopiedInvoice: boolean;
	_isPaying: boolean;
	_showQR: boolean;
	invoice?: string;
	paid?: boolean;
	paymentMethods: PaymentMethods;
	protected updated(changedProperties: PropertyValues): void;
	private renderHeading;
	private renderPaidState;
	private renderPayingState;
	private renderPaymentConfirmation;
	private renderWaitingForPayment;
	private renderConnectWalletMobile;
	private renderConnectWalletDesktop;
	private renderQR;
	private renderMemo;
	render(): import("lit").TemplateResult<1> | null;
	private _onClickConnectWallet;
	private _copyAndDisplayInvoice;
	private _copyInvoice;
	private _payInvoice;
}
declare const routes: {
	"/start": import("lit").TemplateResult<1>;
	"/help": import("lit").TemplateResult<1>;
	"/nwc": import("lit").TemplateResult<1>;
	"/lnfi": import("lit").TemplateResult<1>;
	"/alby-hub": import("lit").TemplateResult<1>;
	"/alby-go": import("lit").TemplateResult<1>;
	"/lnbits": import("lit").TemplateResult<1>;
	"/lnbits-nwc": import("lit").TemplateResult<1>;
	"/flash-wallet": import("lit").TemplateResult<1>;
	"/primal": import("lit").TemplateResult<1>;
	"/cashu-me": import("lit").TemplateResult<1>;
	"/rizful": import("lit").TemplateResult<1>;
	"/new-wallet": import("lit").TemplateResult<1>;
	"/connected": import("lit").TemplateResult<1>;
};
export declare type Route = keyof typeof routes;
declare class BitcoinConnectElement extends InternalElement {
	protected _modalOpen: boolean;
	protected _connected: boolean;
	protected _connecting: boolean;
	protected _connectorName: string | undefined;
	protected _appName: string | undefined;
	protected _appIcon: string | undefined;
	protected _filters: ConnectorFilter[] | undefined;
	protected _error: string | undefined;
	protected _route: Route;
	constructor();
}
declare const Button_base: typeof BitcoinConnectElement;
/**
 * A button that when clicked launches the modal.
 */
export declare class Button extends Button_base {
	title: string;
	protected _showBalance: boolean | undefined;
	constructor();
	render(): import("lit").TemplateResult<1>;
	private _onClick;
}
declare const PayButton_base: typeof BitcoinConnectElement;
/**
 * A button that when clicked launches a modal to pay an invoice.
 */
export declare class PayButton extends PayButton_base {
	title: string;
	invoice?: string;
	paymentMethods: PaymentMethods;
	preimage?: string;
	/**
	 * This will be set to true if the button was clicked
	 * when no invoice is set on the button. The loading
	 * state will show until an invoice is set.
	 */
	_waitingForInvoice: boolean;
	_paid: boolean;
	private _setPaid?;
	protected updated(changedProperties: PropertyValues): void;
	render(): import("lit").TemplateResult<1>;
	private _onClick;
	private _launchModal;
}
declare const Modal_base: typeof BitcoinConnectElement;
export declare class Modal extends Modal_base {
	render(): import("lit").TemplateResult<1>;
	private _handleClose;
}
declare const ConnectFlow_base: typeof BitcoinConnectElement;
export declare class ConnectFlow extends ConnectFlow_base {
	static styles: import("lit").CSSResult[];
	closable?: boolean;
	render(): import("lit").TemplateResult<1>;
}
declare const SendPaymentFlow_base: typeof BitcoinConnectElement;
export declare class SendPaymentFlow extends SendPaymentFlow_base {
	static styles: import("lit").CSSResult[];
	closable?: boolean;
	invoice?: string;
	paymentMethods: PaymentMethods;
	paid?: boolean;
	_showConnect: boolean;
	constructor();
	render(): import("lit").TemplateResult<1>;
	private _onClickConnectWallet;
}
export declare type WebLNProviderConfig = {
	nwc?: {
		authorizationUrlOptions: NWCAuthorizationUrlOptions;
	};
};
export declare type BitcoinConnectConfig = {
	/**
	 * Name of the application that the user is interacting with.
	 *   May be passed to the connector the user chooses to connect with (e.g. NWC)
	 */
	appName?: string;
	/**
	 * Icon of the application that the user is interacting with.
	 *   May be passed to the connector the user chooses to connect with (e.g. NWC)
	 */
	appIcon?: string;
	/**
	 * Limit which connectors are shown in the connect flow
	 */
	filters?: ConnectorFilter[];
	/**
	 * Set to false to not request or show the user's wallet balance
	 */
	showBalance?: boolean;
	/**
	 * Automatically connect to a user's NWC wallet when the page loads
	 * NWC connection URL is passed as a hash parameter (URL encoded)
	 * Example: https://myapp.com/#/?nwc=nostr%2Bwalletconnect%3A%2F%2F...
	 * @default true
	 */
	autoConnect?: boolean;
	/**
	 * Save connection configuration to local storage for persistence
	 * Set to false for apps that only need to initialize connection and get NWC secret
	 * @default true
	 */
	persistConnection?: boolean;
	/**
	 * Customize individual providers (NWC, LNC, LNbits etc)
	 */
	providerConfig?: WebLNProviderConfig;
};
export declare type LaunchPaymentModalArgs = {
	/**
	 * Launch a payment flow to pay a BOLT11 invoice
	 */
	invoice: string;
	/**
	 * Supported payment methods in payment flow
	 */
	paymentMethods?: PaymentMethods;
	/**
	 * Called when a payment is made (either with WebLN or externally)
	 * @param response response of the WebLN send payment call
	 */
	onPaid?: (response: SendPaymentResponse) => void;
	/**
	 * Called when modal is closed without completing the payment
	 */
	onCancelled?: () => void;
};
/**
 * Subscribe to onConnected events which will fire when a wallet is connected (either
 * the user connects to a new wallet or when Bitcoin Connect boots and connects to a previously-connected wallet).
 *
 * If a provider is already available when the subscription is created, the callback will be immediately fired.
 * @param callback includes the webln provider that was (or is already) connected
 * @returns unsubscribe function
 */
export declare function onConnected(callback: (provider: WebLNProvider) => void): () => void;
/**
 * Listen to onConnecting events which will fire when a user is connecting to their wallet
 * Subscribe to onConnecting events which will fire when a user is connecting to their wallet
 *
 * If a provider is already being connected to when the subscription is created, the callback will be immediately fired.
 * @param callback
 * @returns unsubscribe function
 */
export declare function onConnecting(callback: () => void): () => void;
/**
 * Listen to onDisconnected events which will fire when a user disconnects from their wallet
 * @param callback
 * @returns unsubscribe function
 */
export declare function onDisconnected(callback: () => void): () => void;
/**
 * Listen to onModalOpened events which will fire when a Bitcoin Connect modal is opened
 * @param callback
 * @returns unsubscribe function
 */
export declare function onModalOpened(callback: () => void): () => void;
/**
 * Listen to onModalOpened events which will fire when a Bitcoin Connect modal is closed
 * @param callback
 * @returns unsubscribe function
 */
export declare function onModalClosed(callback: () => void): () => void;
/**
 * If a WebLN provider already exists, returns the current WebLN provider. Otherwise
 *   will launch the modal to allow the user to connect to a wallet,
 *   and then enable the WebLN provider for that wallet.
 * @returns an enabled WebLN provider.
 * @throws Error if user cancels flow (by closing the modal)
 */
export declare function requestProvider(): Promise<WebLNProvider>;
/**
 * @returns true if user is connected to a wallet and WebLN is enabled
 * @deprecated will be removed in v4.
 */
export declare function isConnected(): boolean;
/**
 * Configures Bitcoin Connect
 * @param config
 */
export declare function init(config?: BitcoinConnectConfig): void;
/**
 * Refresh the balance of the connected wallet
 */
export declare function refreshBalance(): void;
/**
 * Programmatically launch the Bitcoin Connect modal
 */
export declare function launchModal(): void;
/**
 * Programmatically launch the Bitcoin Connect modal to receive a payment
 * @param args configure the payment modal
 *
 * @returns an object allowing you to mark the payment as made (for external payments)
 */
export declare function launchPaymentModal({ invoice, paymentMethods, onPaid, onCancelled, }: LaunchPaymentModalArgs): {
	setPaid: (sendPaymentResponse: SendPaymentResponse) => void;
};
/**
 * Programmatically close the modal
 */
export declare function closeModal(): void;
/**
 * Programmatically connect to a user's wallet
 */
export declare function connect(config: ConnectorConfig): void;
/**
 * Programmatically connect to a user's NWC wallet
 */
export declare function connectNWC(nwcUrl: string): void;
/**
 * Programmatically disconnect from a user's wallet and remove saved configuration
 */
export declare function disconnect(): void;
/**
 * @returns the configuration of the current connector (if connected)
 */
export declare function getConnectorConfig(): ConnectorConfig | undefined;
export declare const WebLNProviders: {
	NostrWebLNProvider: typeof NostrWebLNProvider;
	LNCWebLNProvider: typeof LNCWebLNProvider;
	LnbitsWebLNProvider: typeof LnbitsWebLNProvider;
};

export {
	ExtensionConnector$1 as ExtensionConnector,
	LNCConnector$1 as LNCConnector,
};

export {};
